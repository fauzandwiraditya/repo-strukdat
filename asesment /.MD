    SSLinventory.h
#ifndef SLLINVENTORY_H
#define SLLINVENTORY_H

#include <string>
using namespace std;

struct Product {
    string Nama;
    string SKU;
    int Jumlah;
    float HargaSatuan;
    float DiskonPersen; 
};

struct Node;
typedef Node* address;

struct Node {
    Product info;
    address next;
};

struct List {
    address head;
};

bool isEmpty(List L);
void createList(List &L);

address allocate(Product P);
void deallocate(address addr);

void insertFirst(List &L, Product P);
void insertLast(List &L, Product P);
void insertAfter(List &L, address Q, Product P);

void deleteFirst(List &L, Product &P);
void deleteLast(List &L, Product &P);
void deleteAfter(List &L, address Q, Product &P);

void updateAtPosition(List &L, int posisi);

void viewList(List L);

void searchByFinalPriceRange(List L, float minPrice, float maxPrice);


void MaxHargaAkhir(List L);

#endif


   SLLInventory.cpp  


#include "SLLInventory.h"
#include <iostream>
using namespace std;

bool isEmpty(List L) {
    return L.head == nullptr;
}

void createList(List &L) {
    L.head = nullptr;
}

address allocate(Product P) {
    address newNode = new Node;
    newNode->info = P;
    newNode->next = nullptr;
    return newNode;
}

void deallocate(address addr) {
    delete addr;
}

void insertFirst(List &L, Product P) {
    address x = allocate(P);
    x->next = L.head;
    L.head = x;
}

void insertLast(List &L, Product P) {
    address x = allocate(P);
    if (isEmpty(L)) {
        L.head = x;
    } else {
        address temp = L.head;
        while (temp->next != nullptr)
            temp = temp->next;
        temp->next = x;
    }
}

void insertAfter(List &L, address Q, Product P) {
    if (Q != nullptr) {
        address x = allocate(P);
        x->next = Q->next;
        Q->next = x;
    }
}

void deleteFirst(List &L, Product &P) {
    if (!isEmpty(L)) {
        address del = L.head;
        P = del->info;
        L.head = del->next;
        deallocate(del);
    }
}

void deleteLast(List &L, Product &P) {
    if (!isEmpty(L)) {
        if (L.head->next == nullptr) {
            P = L.head->info;
            deallocate(L.head);
            L.head = nullptr;
        } else {
            address temp = L.head;
            while (temp->next->next != nullptr)
                temp = temp->next;
            address del = temp->next;
            P = del->info;
            temp->next = nullptr;
            deallocate(del);
        }
    }
}

void deleteAfter(List &L, address Q, Product &P) {
    if (Q != nullptr && Q->next != nullptr) {
        address del = Q->next;
        P = del->info;
        Q->next = del->next;
        deallocate(del);
    }
}

void updateAtPosition(List &L, int posisi) {
    address temp = L.head;
    int idx = 1;

    while (temp != nullptr && idx < posisi) {
        temp = temp->next;
        idx++;
    }

    if (temp == nullptr) {
        cout << "Posisi tidak valid!\n";
        return;
    }

    cout << "Nama: "; cin >> temp->info.Nama;
    cout << "SKU: "; cin >> temp->info.SKU;
    cout << "Jumlah: "; cin >> temp->info.Jumlah;
    cout << "Harga Satuan: "; cin >> temp->info.HargaSatuan;
    cout << "Diskon Persen: "; cin >> temp->info.DiskonPersen;
}

void viewList(List L) {
    if (isEmpty(L)) {
        cout << "List kosong.\n";
        return;
    }

    address temp = L.head;
    int idx = 1;

    while (temp != nullptr) {
        float hargaAkhir = temp->info.HargaSatuan * (1 - temp->info.DiskonPersen / 100);

        cout << idx << ". "
             << temp->info.Nama << " | "
             << temp->info.SKU << " | "
             << temp->info.Jumlah << " | "
             << temp->info.HargaSatuan << " | "
             << temp->info.DiskonPersen << "% | "
             << "Harga Akhir: " << hargaAkhir << endl;

        temp = temp->next;
        idx++;
    }
}

void searchByFinalPriceRange(List L, float minPrice, float maxPrice) {
    address temp = L.head;
    int idx = 1;
    bool found = false;

    while (temp != nullptr) {
        float hargaAkhir = temp->info.HargaSatuan * (1 - temp->info.DiskonPersen / 100);
        if (hargaAkhir >= minPrice && hargaAkhir <= maxPrice) {
            cout << "Posisi " << idx << ": "
                 << temp->info.Nama << " | Harga Akhir = " << hargaAkhir << endl;
            found = true;
        }
        temp = temp->next;
        idx++;
    }

    if (!found)
        cout << "Tidak ada produk dalam rentang harga.\n";
}

void MaxHargaAkhir(List L) {
    if (isEmpty(L)) {
        cout << "List kosong.\n";
        return;
    }

    address temp = L.head;
    float maxHarga = temp->info.HargaSatuan * (1 - temp->info.DiskonPersen / 100);

    while (temp != nullptr) {
        float hargaAkhir = temp->info.HargaSatuan * (1 - temp->info.DiskonPersen / 100);
        if (hargaAkhir > maxHarga)
            maxHarga = hargaAkhir;

        temp = temp->next;
    }

    cout << "\nProduk dengan HargaAkhir terbesar (" << maxHarga << "):\n";

    temp = L.head;
    int idx = 1;
    while (temp != nullptr) {
        float hargaAkhir = temp->info.HargaSatuan * (1 - temp->info.DiskonPersen / 100);
        if (hargaAkhir == maxHarga) {
            cout << "Posisi " << idx << ": "
                 << temp->info.Nama << " | "
                 << temp->info.SKU << " | "
                 << hargaAkhir << endl;
        }
        temp = temp->next;
        idx++;
    }
}


   main.cpp

#include <iostream>
#include "SLLInventory.h"
using namespace std;

int main() {
    List L;
    createList(L);

    Product p;

    p = {"Pulpen", "A001", 20, 2500, 0};
    insertLast(L, p);

    p = {"BukuTulis", "A002", 15, 5000, 10};
    insertLast(L, p);

    p = {"Penghapus", "A003", 30, 1500, 0};
    insertLast(L, p);

    cout << "\n=== List Awal ===\n";
    viewList(L);

    Product deleted;
    deleteFirst(L, deleted);

    cout << "\n=== Setelah deleteFirst ===\n";
    viewList(L);

    cout << "\nMasukkan data baru posisi ke-2:\n";
    updateAtPosition(L, 2);

    cout << "\n=== Setelah update ===\n";
    viewList(L);

    cout << "\n=== Searching harga akhir 2000 - 7000 ===\n";
    searchByFinalPriceRange(L, 2000, 7000);

    cout << "\n=== Produk dengan HargaAkhir Maksimum ===\n";
    MaxHargaAkhir(L);

    return 0;
}

